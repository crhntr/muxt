// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"html/template"
	"net/http"
	"sync"

	"github.com/crhntr/template/internal/example"
)

type ArticleService struct {
	CheckAuthStub        func(*http.Request) (string, error)
	checkAuthMutex       sync.RWMutex
	checkAuthArgsForCall []struct {
		arg1 *http.Request
	}
	checkAuthReturns struct {
		result1 string
		result2 error
	}
	checkAuthReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetCommentStub        func(context.Context, int, int) (string, error)
	getCommentMutex       sync.RWMutex
	getCommentArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	getCommentReturns struct {
		result1 string
		result2 error
	}
	getCommentReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HandlerStub        func(http.ResponseWriter, *http.Request) template.HTML
	handlerMutex       sync.RWMutex
	handlerArgsForCall []struct {
		arg1 http.ResponseWriter
		arg2 *http.Request
	}
	handlerReturns struct {
		result1 template.HTML
	}
	handlerReturnsOnCall map[int]struct {
		result1 template.HTML
	}
	ListArticlesStub        func(context.Context) ([]example.Article, error)
	listArticlesMutex       sync.RWMutex
	listArticlesArgsForCall []struct {
		arg1 context.Context
	}
	listArticlesReturns struct {
		result1 []example.Article
		result2 error
	}
	listArticlesReturnsOnCall map[int]struct {
		result1 []example.Article
		result2 error
	}
	NumAuthorsStub        func() int
	numAuthorsMutex       sync.RWMutex
	numAuthorsArgsForCall []struct {
	}
	numAuthorsReturns struct {
		result1 int
	}
	numAuthorsReturnsOnCall map[int]struct {
		result1 int
	}
	ParseStub        func(string) []string
	parseMutex       sync.RWMutex
	parseArgsForCall []struct {
		arg1 string
	}
	parseReturns struct {
		result1 []string
	}
	parseReturnsOnCall map[int]struct {
		result1 []string
	}
	SomeStringStub        func(context.Context, string) (string, error)
	someStringMutex       sync.RWMutex
	someStringArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	someStringReturns struct {
		result1 string
		result2 error
	}
	someStringReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ToUpperStub        func(...rune) string
	toUpperMutex       sync.RWMutex
	toUpperArgsForCall []struct {
		arg1 []rune
	}
	toUpperReturns struct {
		result1 string
	}
	toUpperReturnsOnCall map[int]struct {
		result1 string
	}
	TooManyResultsStub        func() (int, int, int)
	tooManyResultsMutex       sync.RWMutex
	tooManyResultsArgsForCall []struct {
	}
	tooManyResultsReturns struct {
		result1 int
		result2 int
		result3 int
	}
	tooManyResultsReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ArticleService) CheckAuth(arg1 *http.Request) (string, error) {
	fake.checkAuthMutex.Lock()
	ret, specificReturn := fake.checkAuthReturnsOnCall[len(fake.checkAuthArgsForCall)]
	fake.checkAuthArgsForCall = append(fake.checkAuthArgsForCall, struct {
		arg1 *http.Request
	}{arg1})
	stub := fake.CheckAuthStub
	fakeReturns := fake.checkAuthReturns
	fake.recordInvocation("CheckAuth", []interface{}{arg1})
	fake.checkAuthMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ArticleService) CheckAuthCallCount() int {
	fake.checkAuthMutex.RLock()
	defer fake.checkAuthMutex.RUnlock()
	return len(fake.checkAuthArgsForCall)
}

func (fake *ArticleService) CheckAuthCalls(stub func(*http.Request) (string, error)) {
	fake.checkAuthMutex.Lock()
	defer fake.checkAuthMutex.Unlock()
	fake.CheckAuthStub = stub
}

func (fake *ArticleService) CheckAuthArgsForCall(i int) *http.Request {
	fake.checkAuthMutex.RLock()
	defer fake.checkAuthMutex.RUnlock()
	argsForCall := fake.checkAuthArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ArticleService) CheckAuthReturns(result1 string, result2 error) {
	fake.checkAuthMutex.Lock()
	defer fake.checkAuthMutex.Unlock()
	fake.CheckAuthStub = nil
	fake.checkAuthReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) CheckAuthReturnsOnCall(i int, result1 string, result2 error) {
	fake.checkAuthMutex.Lock()
	defer fake.checkAuthMutex.Unlock()
	fake.CheckAuthStub = nil
	if fake.checkAuthReturnsOnCall == nil {
		fake.checkAuthReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.checkAuthReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) GetComment(arg1 context.Context, arg2 int, arg3 int) (string, error) {
	fake.getCommentMutex.Lock()
	ret, specificReturn := fake.getCommentReturnsOnCall[len(fake.getCommentArgsForCall)]
	fake.getCommentArgsForCall = append(fake.getCommentArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.GetCommentStub
	fakeReturns := fake.getCommentReturns
	fake.recordInvocation("GetComment", []interface{}{arg1, arg2, arg3})
	fake.getCommentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ArticleService) GetCommentCallCount() int {
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	return len(fake.getCommentArgsForCall)
}

func (fake *ArticleService) GetCommentCalls(stub func(context.Context, int, int) (string, error)) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = stub
}

func (fake *ArticleService) GetCommentArgsForCall(i int) (context.Context, int, int) {
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	argsForCall := fake.getCommentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ArticleService) GetCommentReturns(result1 string, result2 error) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = nil
	fake.getCommentReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) GetCommentReturnsOnCall(i int, result1 string, result2 error) {
	fake.getCommentMutex.Lock()
	defer fake.getCommentMutex.Unlock()
	fake.GetCommentStub = nil
	if fake.getCommentReturnsOnCall == nil {
		fake.getCommentReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getCommentReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) Handler(arg1 http.ResponseWriter, arg2 *http.Request) template.HTML {
	fake.handlerMutex.Lock()
	ret, specificReturn := fake.handlerReturnsOnCall[len(fake.handlerArgsForCall)]
	fake.handlerArgsForCall = append(fake.handlerArgsForCall, struct {
		arg1 http.ResponseWriter
		arg2 *http.Request
	}{arg1, arg2})
	stub := fake.HandlerStub
	fakeReturns := fake.handlerReturns
	fake.recordInvocation("Handler", []interface{}{arg1, arg2})
	fake.handlerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ArticleService) HandlerCallCount() int {
	fake.handlerMutex.RLock()
	defer fake.handlerMutex.RUnlock()
	return len(fake.handlerArgsForCall)
}

func (fake *ArticleService) HandlerCalls(stub func(http.ResponseWriter, *http.Request) template.HTML) {
	fake.handlerMutex.Lock()
	defer fake.handlerMutex.Unlock()
	fake.HandlerStub = stub
}

func (fake *ArticleService) HandlerArgsForCall(i int) (http.ResponseWriter, *http.Request) {
	fake.handlerMutex.RLock()
	defer fake.handlerMutex.RUnlock()
	argsForCall := fake.handlerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ArticleService) HandlerReturns(result1 template.HTML) {
	fake.handlerMutex.Lock()
	defer fake.handlerMutex.Unlock()
	fake.HandlerStub = nil
	fake.handlerReturns = struct {
		result1 template.HTML
	}{result1}
}

func (fake *ArticleService) HandlerReturnsOnCall(i int, result1 template.HTML) {
	fake.handlerMutex.Lock()
	defer fake.handlerMutex.Unlock()
	fake.HandlerStub = nil
	if fake.handlerReturnsOnCall == nil {
		fake.handlerReturnsOnCall = make(map[int]struct {
			result1 template.HTML
		})
	}
	fake.handlerReturnsOnCall[i] = struct {
		result1 template.HTML
	}{result1}
}

func (fake *ArticleService) ListArticles(arg1 context.Context) ([]example.Article, error) {
	fake.listArticlesMutex.Lock()
	ret, specificReturn := fake.listArticlesReturnsOnCall[len(fake.listArticlesArgsForCall)]
	fake.listArticlesArgsForCall = append(fake.listArticlesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListArticlesStub
	fakeReturns := fake.listArticlesReturns
	fake.recordInvocation("ListArticles", []interface{}{arg1})
	fake.listArticlesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ArticleService) ListArticlesCallCount() int {
	fake.listArticlesMutex.RLock()
	defer fake.listArticlesMutex.RUnlock()
	return len(fake.listArticlesArgsForCall)
}

func (fake *ArticleService) ListArticlesCalls(stub func(context.Context) ([]example.Article, error)) {
	fake.listArticlesMutex.Lock()
	defer fake.listArticlesMutex.Unlock()
	fake.ListArticlesStub = stub
}

func (fake *ArticleService) ListArticlesArgsForCall(i int) context.Context {
	fake.listArticlesMutex.RLock()
	defer fake.listArticlesMutex.RUnlock()
	argsForCall := fake.listArticlesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ArticleService) ListArticlesReturns(result1 []example.Article, result2 error) {
	fake.listArticlesMutex.Lock()
	defer fake.listArticlesMutex.Unlock()
	fake.ListArticlesStub = nil
	fake.listArticlesReturns = struct {
		result1 []example.Article
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) ListArticlesReturnsOnCall(i int, result1 []example.Article, result2 error) {
	fake.listArticlesMutex.Lock()
	defer fake.listArticlesMutex.Unlock()
	fake.ListArticlesStub = nil
	if fake.listArticlesReturnsOnCall == nil {
		fake.listArticlesReturnsOnCall = make(map[int]struct {
			result1 []example.Article
			result2 error
		})
	}
	fake.listArticlesReturnsOnCall[i] = struct {
		result1 []example.Article
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) NumAuthors() int {
	fake.numAuthorsMutex.Lock()
	ret, specificReturn := fake.numAuthorsReturnsOnCall[len(fake.numAuthorsArgsForCall)]
	fake.numAuthorsArgsForCall = append(fake.numAuthorsArgsForCall, struct {
	}{})
	stub := fake.NumAuthorsStub
	fakeReturns := fake.numAuthorsReturns
	fake.recordInvocation("NumAuthors", []interface{}{})
	fake.numAuthorsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ArticleService) NumAuthorsCallCount() int {
	fake.numAuthorsMutex.RLock()
	defer fake.numAuthorsMutex.RUnlock()
	return len(fake.numAuthorsArgsForCall)
}

func (fake *ArticleService) NumAuthorsCalls(stub func() int) {
	fake.numAuthorsMutex.Lock()
	defer fake.numAuthorsMutex.Unlock()
	fake.NumAuthorsStub = stub
}

func (fake *ArticleService) NumAuthorsReturns(result1 int) {
	fake.numAuthorsMutex.Lock()
	defer fake.numAuthorsMutex.Unlock()
	fake.NumAuthorsStub = nil
	fake.numAuthorsReturns = struct {
		result1 int
	}{result1}
}

func (fake *ArticleService) NumAuthorsReturnsOnCall(i int, result1 int) {
	fake.numAuthorsMutex.Lock()
	defer fake.numAuthorsMutex.Unlock()
	fake.NumAuthorsStub = nil
	if fake.numAuthorsReturnsOnCall == nil {
		fake.numAuthorsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numAuthorsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *ArticleService) Parse(arg1 string) []string {
	fake.parseMutex.Lock()
	ret, specificReturn := fake.parseReturnsOnCall[len(fake.parseArgsForCall)]
	fake.parseArgsForCall = append(fake.parseArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ParseStub
	fakeReturns := fake.parseReturns
	fake.recordInvocation("Parse", []interface{}{arg1})
	fake.parseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ArticleService) ParseCallCount() int {
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	return len(fake.parseArgsForCall)
}

func (fake *ArticleService) ParseCalls(stub func(string) []string) {
	fake.parseMutex.Lock()
	defer fake.parseMutex.Unlock()
	fake.ParseStub = stub
}

func (fake *ArticleService) ParseArgsForCall(i int) string {
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	argsForCall := fake.parseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ArticleService) ParseReturns(result1 []string) {
	fake.parseMutex.Lock()
	defer fake.parseMutex.Unlock()
	fake.ParseStub = nil
	fake.parseReturns = struct {
		result1 []string
	}{result1}
}

func (fake *ArticleService) ParseReturnsOnCall(i int, result1 []string) {
	fake.parseMutex.Lock()
	defer fake.parseMutex.Unlock()
	fake.ParseStub = nil
	if fake.parseReturnsOnCall == nil {
		fake.parseReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.parseReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *ArticleService) SomeString(arg1 context.Context, arg2 string) (string, error) {
	fake.someStringMutex.Lock()
	ret, specificReturn := fake.someStringReturnsOnCall[len(fake.someStringArgsForCall)]
	fake.someStringArgsForCall = append(fake.someStringArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SomeStringStub
	fakeReturns := fake.someStringReturns
	fake.recordInvocation("SomeString", []interface{}{arg1, arg2})
	fake.someStringMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ArticleService) SomeStringCallCount() int {
	fake.someStringMutex.RLock()
	defer fake.someStringMutex.RUnlock()
	return len(fake.someStringArgsForCall)
}

func (fake *ArticleService) SomeStringCalls(stub func(context.Context, string) (string, error)) {
	fake.someStringMutex.Lock()
	defer fake.someStringMutex.Unlock()
	fake.SomeStringStub = stub
}

func (fake *ArticleService) SomeStringArgsForCall(i int) (context.Context, string) {
	fake.someStringMutex.RLock()
	defer fake.someStringMutex.RUnlock()
	argsForCall := fake.someStringArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ArticleService) SomeStringReturns(result1 string, result2 error) {
	fake.someStringMutex.Lock()
	defer fake.someStringMutex.Unlock()
	fake.SomeStringStub = nil
	fake.someStringReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) SomeStringReturnsOnCall(i int, result1 string, result2 error) {
	fake.someStringMutex.Lock()
	defer fake.someStringMutex.Unlock()
	fake.SomeStringStub = nil
	if fake.someStringReturnsOnCall == nil {
		fake.someStringReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.someStringReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ArticleService) ToUpper(arg1 ...rune) string {
	fake.toUpperMutex.Lock()
	ret, specificReturn := fake.toUpperReturnsOnCall[len(fake.toUpperArgsForCall)]
	fake.toUpperArgsForCall = append(fake.toUpperArgsForCall, struct {
		arg1 []rune
	}{arg1})
	stub := fake.ToUpperStub
	fakeReturns := fake.toUpperReturns
	fake.recordInvocation("ToUpper", []interface{}{arg1})
	fake.toUpperMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ArticleService) ToUpperCallCount() int {
	fake.toUpperMutex.RLock()
	defer fake.toUpperMutex.RUnlock()
	return len(fake.toUpperArgsForCall)
}

func (fake *ArticleService) ToUpperCalls(stub func(...rune) string) {
	fake.toUpperMutex.Lock()
	defer fake.toUpperMutex.Unlock()
	fake.ToUpperStub = stub
}

func (fake *ArticleService) ToUpperArgsForCall(i int) []rune {
	fake.toUpperMutex.RLock()
	defer fake.toUpperMutex.RUnlock()
	argsForCall := fake.toUpperArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ArticleService) ToUpperReturns(result1 string) {
	fake.toUpperMutex.Lock()
	defer fake.toUpperMutex.Unlock()
	fake.ToUpperStub = nil
	fake.toUpperReturns = struct {
		result1 string
	}{result1}
}

func (fake *ArticleService) ToUpperReturnsOnCall(i int, result1 string) {
	fake.toUpperMutex.Lock()
	defer fake.toUpperMutex.Unlock()
	fake.ToUpperStub = nil
	if fake.toUpperReturnsOnCall == nil {
		fake.toUpperReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.toUpperReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ArticleService) TooManyResults() (int, int, int) {
	fake.tooManyResultsMutex.Lock()
	ret, specificReturn := fake.tooManyResultsReturnsOnCall[len(fake.tooManyResultsArgsForCall)]
	fake.tooManyResultsArgsForCall = append(fake.tooManyResultsArgsForCall, struct {
	}{})
	stub := fake.TooManyResultsStub
	fakeReturns := fake.tooManyResultsReturns
	fake.recordInvocation("TooManyResults", []interface{}{})
	fake.tooManyResultsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *ArticleService) TooManyResultsCallCount() int {
	fake.tooManyResultsMutex.RLock()
	defer fake.tooManyResultsMutex.RUnlock()
	return len(fake.tooManyResultsArgsForCall)
}

func (fake *ArticleService) TooManyResultsCalls(stub func() (int, int, int)) {
	fake.tooManyResultsMutex.Lock()
	defer fake.tooManyResultsMutex.Unlock()
	fake.TooManyResultsStub = stub
}

func (fake *ArticleService) TooManyResultsReturns(result1 int, result2 int, result3 int) {
	fake.tooManyResultsMutex.Lock()
	defer fake.tooManyResultsMutex.Unlock()
	fake.TooManyResultsStub = nil
	fake.tooManyResultsReturns = struct {
		result1 int
		result2 int
		result3 int
	}{result1, result2, result3}
}

func (fake *ArticleService) TooManyResultsReturnsOnCall(i int, result1 int, result2 int, result3 int) {
	fake.tooManyResultsMutex.Lock()
	defer fake.tooManyResultsMutex.Unlock()
	fake.TooManyResultsStub = nil
	if fake.tooManyResultsReturnsOnCall == nil {
		fake.tooManyResultsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 int
		})
	}
	fake.tooManyResultsReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 int
	}{result1, result2, result3}
}

func (fake *ArticleService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkAuthMutex.RLock()
	defer fake.checkAuthMutex.RUnlock()
	fake.getCommentMutex.RLock()
	defer fake.getCommentMutex.RUnlock()
	fake.handlerMutex.RLock()
	defer fake.handlerMutex.RUnlock()
	fake.listArticlesMutex.RLock()
	defer fake.listArticlesMutex.RUnlock()
	fake.numAuthorsMutex.RLock()
	defer fake.numAuthorsMutex.RUnlock()
	fake.parseMutex.RLock()
	defer fake.parseMutex.RUnlock()
	fake.someStringMutex.RLock()
	defer fake.someStringMutex.RUnlock()
	fake.toUpperMutex.RLock()
	defer fake.toUpperMutex.RUnlock()
	fake.tooManyResultsMutex.RLock()
	defer fake.tooManyResultsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ArticleService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
