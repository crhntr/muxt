exec go get github.com/crhntr/dom@v0.2.3
exec go mod tidy

muxt generate --receiver-type=App --routes-func=Routes
muxt check

exec go test -v
-- go.mod --
module example.com

go 1.24
-- app.go --
package blog

type App struct{}

type Article struct {
	Title   string
	Content string
	Error   error
}

func (*App) Article(id int) Article {
	return Article{} // noop, the fake will be used to set values in test cases
}
-- cmd/server/main.go --
package main

import (
	"cmp"
	"log"
	"net/http"
	"os"

	"example.com"
)

func main() {
	mux := http.NewServeMux()
	app := new(blog.App)
	blog.Routes(mux, app)
	log.Fatal(http.ListenAndServe(":"+cmp.Or(os.Getenv("PORT"), "8080"), mux))
}
-- pages.gohtml --
{{define "meta"}}
	  <meta charset="UTF-8">
	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
{{end}}

{{define "article-content"}}
	<h1>{{.Result.Title}}</h1>
	<p>{{.Result.Content}}</p>
{{end}}

{{define "article-page"}}
{{if .Request.Header.Get "HX-Request" }}
	{{template "article-content" .}}
{{else}}
<!DOCTYPE html>
<html lang="en">
<head>
    {{template "meta"}}
	<title>Article [{{.Request.PathValue "id"}}]</title>
</head>
<body>
  {{template "article-content" .}}
</body>
</html>
{{end}}
{{end}}

{{define "GET /article/{id} Article(id)"}}
	{{- if .Result.Error -}}
		{{template "error-page" .}}
	{{- else -}}
		{{template "article-page" .}}
	{{- end -}}
{{end}}

{{define "error-message"}}
    {{- /* gotype: builtin.error */ -}}
		<p id='error-message' style='color: darkred;' data-type='{{printf "%T" .}}'>{{.}}</p>
{{end}}

{{define "error-page"}}
  {{if .Request.Header.Get "HX-Request" }}
      {{template "error-message" .Result.Error}}
  {{else}}
		<!DOCTYPE html>
		<html lang="en">
		<head>
        {{template "meta"}}
			<title>Error</title>
		</head>
		<body>
    {{template "error-message" .Result.Error}}
		</body>
		</html>
  {{end}}
{{end}}

-- template.go --
package blog

import (
	"embed"
	"text/template"
)

//go:generate counterfeiter -generate
//counterfeiter:generate -o internal/fake/app.go --fake-name App . RoutesReceiver

//go:embed *.gohtml
var source embed.FS

var templates = template.Must(template.ParseFS(source, "*.gohtml"))
-- template_test.go --
package blog_test

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/net/html/atom"

	"github.com/crhntr/dom/domtest"
	"github.com/crhntr/dom/spec"

	"example.com"
	"example.com/internal/fake"
)

func TestCase(t *testing.T) {
	for _, tt := range []domtest.Case[*testing.T, fake.App]{
		{
			Name: "viewing the home page",
			Given: func(t *testing.T, app *fake.App) {
				app.ArticleReturns(blog.Article{
					Title:   "Greetings!",
					Content: "Hello, friends!",
					Error:   nil,
				})
			},
			When: func(t *testing.T) *http.Request {
				return httptest.NewRequest(http.MethodGet, "/article/1", nil)
			},
			Then: domtest.Document(func(t *testing.T, document spec.Document, app *fake.App) {
				require.Equal(t, 1, app.ArticleArgsForCall(0))
				if heading := document.QuerySelector("h1"); assert.NotNil(t, heading) {
					require.Equal(t, "Greetings!", heading.TextContent())
				}
				if content := document.QuerySelector("p"); assert.NotNil(t, content) {
					require.Equal(t, "Hello, friends!", content.TextContent())
				}
			}),
		},
		{
			Name: "the page has an error",
			Given: func(t *testing.T, app *fake.App) {
				app.ArticleReturns(blog.Article{
					Error: fmt.Errorf("lemon"),
				})
			},
			When: func(t *testing.T) *http.Request {
				return httptest.NewRequest(http.MethodGet, "/article/1", nil)
			},
			Then: domtest.QuerySelector("#error-message", func(t *testing.T, msg spec.Element, app *fake.App) {
				require.Equal(t, "lemon", msg.TextContent())
			}),
		},
		{
			Name: "the page has an error and is requested by HTMX",
			Given: func(t *testing.T, app *fake.App) {
				app.ArticleReturns(blog.Article{
					Error: fmt.Errorf("lemon"),
				})
			},
			When: func(t *testing.T) *http.Request {
				req := httptest.NewRequest(http.MethodGet, "/article/1", nil)
				req.Header.Set("HX-Request", "true")
				return req
			},
			Then: domtest.Fragment(atom.Body, func(t *testing.T, fragment spec.DocumentFragment, app *fake.App) {
				el := fragment.FirstElementChild()
				require.Equal(t, "lemon", el.TextContent())
				require.Equal(t, "*errors.errorString", el.GetAttribute("data-type"))
			}),
		},
		{
			Name: "when the id is not an integer",
			When: func(t *testing.T) *http.Request {
				return httptest.NewRequest(http.MethodGet, "/article/banana", nil)
			},
			Then: func(t *testing.T, res *http.Response, f *fake.App) {
				require.Equal(t, http.StatusBadRequest, res.StatusCode)
			},
		},
	} {
		t.Run(tt.Name, tt.Run(func(fakes *fake.App) http.Handler {
			mux := http.NewServeMux()
			blog.Routes(mux, fakes)
			return mux
		}))
	}
}
-- internal/fake/app.go --
// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"sync"

	"example.com"
)

type App struct {
	ArticleStub        func(int) blog.Article
	articleMutex       sync.RWMutex
	articleArgsForCall []struct {
		arg1 int
	}
	articleReturns struct {
		result1 blog.Article
	}
	articleReturnsOnCall map[int]struct {
		result1 blog.Article
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *App) Article(arg1 int) blog.Article {
	fake.articleMutex.Lock()
	ret, specificReturn := fake.articleReturnsOnCall[len(fake.articleArgsForCall)]
	fake.articleArgsForCall = append(fake.articleArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ArticleStub
	fakeReturns := fake.articleReturns
	fake.recordInvocation("Article", []interface{}{arg1})
	fake.articleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *App) ArticleCallCount() int {
	fake.articleMutex.RLock()
	defer fake.articleMutex.RUnlock()
	return len(fake.articleArgsForCall)
}

func (fake *App) ArticleCalls(stub func(int) blog.Article) {
	fake.articleMutex.Lock()
	defer fake.articleMutex.Unlock()
	fake.ArticleStub = stub
}

func (fake *App) ArticleArgsForCall(i int) int {
	fake.articleMutex.RLock()
	defer fake.articleMutex.RUnlock()
	argsForCall := fake.articleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *App) ArticleReturns(result1 blog.Article) {
	fake.articleMutex.Lock()
	defer fake.articleMutex.Unlock()
	fake.ArticleStub = nil
	fake.articleReturns = struct {
		result1 blog.Article
	}{result1}
}

func (fake *App) ArticleReturnsOnCall(i int, result1 blog.Article) {
	fake.articleMutex.Lock()
	defer fake.articleMutex.Unlock()
	fake.ArticleStub = nil
	if fake.articleReturnsOnCall == nil {
		fake.articleReturnsOnCall = make(map[int]struct {
			result1 blog.Article
		})
	}
	fake.articleReturnsOnCall[i] = struct {
		result1 blog.Article
	}{result1}
}

func (fake *App) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.articleMutex.RLock()
	defer fake.articleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *App) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ blog.RoutesReceiver = new(App)
