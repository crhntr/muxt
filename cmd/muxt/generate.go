package main

import (
	"flag"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"slices"

	"golang.org/x/tools/go/packages"

	"github.com/crhntr/muxt"
	"github.com/crhntr/muxt/internal/source"
)

const (
	CodeGenerationComment = "// Code generated by muxt. DO NOT EDIT."

	outputFlagFlagName    = "output-file"
	templatesVariable     = "templates-variable"
	routesFunc            = "routes-func"
	receiverStaticType    = "receiver-static-type"
	receiverInterfaceName = "receiver-interface-name"

	errIdentSuffix = " value must be a well-formed Go identifier"
)

type Generate struct {
	Package   *packages.Package
	goPackage string
	goFile    string
	goLine    string

	templatesVariable string
	outputFilename    string
	routesFunction    string
	receiverIdent     string

	receiverInterfaceIdent string
}

func newGenerate(args []string, getEnv func(string) string) (Generate, error) {
	g := Generate{
		goPackage: getEnv("GOPACKAGE"),
		goFile:    getEnv("GOFILE"),
		goLine:    getEnv("GOLINE"),
	}
	flagSet := flag.NewFlagSet("generate", flag.ContinueOnError)
	flagSet.StringVar(&g.outputFilename, outputFlagFlagName, muxt.DefaultOutputFileName, "file name of generated output")
	flagSet.StringVar(&g.templatesVariable, templatesVariable, muxt.DefaultTemplatesVariableName, "templates variable name")
	flagSet.StringVar(&g.routesFunction, routesFunc, muxt.DefaultRoutesFunctionName, "file name of generated output")
	flagSet.StringVar(&g.receiverIdent, receiverStaticType, "", "static receiver type identifier")
	flagSet.StringVar(&g.receiverInterfaceIdent, receiverInterfaceName, muxt.DefaultReceiverInterfaceName, "generated interface name")
	if err := flagSet.Parse(args); err != nil {
		return Generate{}, err
	}
	if g.templatesVariable != "" && !token.IsIdentifier(g.templatesVariable) {
		return Generate{}, fmt.Errorf(templatesVariable + errIdentSuffix)
	}
	if g.routesFunction != "" && !token.IsIdentifier(g.routesFunction) {
		return Generate{}, fmt.Errorf(routesFunc + errIdentSuffix)
	}
	if g.receiverIdent != "" && !token.IsIdentifier(g.receiverIdent) {
		return Generate{}, fmt.Errorf(receiverStaticType + errIdentSuffix)
	}
	if g.receiverInterfaceIdent != "" && !token.IsIdentifier(g.receiverInterfaceIdent) {
		return Generate{}, fmt.Errorf(receiverInterfaceName + errIdentSuffix)
	}
	if g.outputFilename != "" && filepath.Ext(g.outputFilename) != ".go" {
		return Generate{}, fmt.Errorf("output filename must use .go extension")
	}
	return g, nil
}

func generateCommand(args []string, workingDirectory string, getEnv func(string) string, stdout, _ /* stderr */ io.Writer) error {
	g, err := newGenerate(args, getEnv)
	if err != nil {
		return err
	}
	list, err := packages.Load(&packages.Config{
		Mode:  packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedEmbedPatterns | packages.NeedEmbedFiles,
		Dir:   workingDirectory,
		Tests: false,
	}, workingDirectory)
	if err != nil {
		return err
	}
	if g.goPackage != "" {
		i := slices.IndexFunc(list, func(p *packages.Package) bool { return p.Name == g.goPackage })
		if i < 0 {
			return fmt.Errorf("package %s not loaded", g.goPackage)
		}
		g.Package = list[i]
	} else if len(list) > 0 {
		g.Package = list[0]
		g.goPackage = list[0].ID
	}
	ts, err := source.Templates(workingDirectory, g.templatesVariable, g.Package.Fset, g.Package.Syntax, g.Package.EmbedFiles)
	if err != nil {
		return err
	}
	templateNames, err := muxt.TemplateNames(ts)
	if err != nil {
		return err
	}
	out := log.New(stdout, "", 0)
	s, err := muxt.Generate(templateNames, ts, g.goPackage, g.templatesVariable, g.routesFunction, g.receiverIdent, g.receiverInterfaceIdent, g.outputFilename, g.Package.Fset, g.Package.Syntax, g.Package.Syntax, out)
	if err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(workingDirectory, g.outputFilename), []byte(CodeGenerationComment+"\n\n"+s), 0o644)
}
