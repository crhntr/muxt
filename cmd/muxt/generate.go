package main

import (
	"flag"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"slices"

	"golang.org/x/tools/go/packages"

	"github.com/crhntr/muxt"
	"github.com/crhntr/muxt/internal/source"
)

const (
	CodeGenerationComment = "// Code generated by muxt. DO NOT EDIT."

	outputFlagFlagName = "output-file"
	templatesVariable  = "templates-variable"
	routesFunc         = "routes-func"
	receiverStaticType = "receiver-static-type"

	errIdentSuffix = " value must be a well-formed Go identifier"
)

type Generate struct {
	Package   *packages.Package
	goPackage string
	goFile    string
	goLine    string

	templatesVariable string
	outputFilename    string
	routesFunction    string
	receiverIdent     string
}

func newGenerate(args []string, getEnv func(string) string) (Generate, error) {
	g := Generate{
		goPackage: getEnv("GOPACKAGE"),
		goFile:    getEnv("GOFILE"),
		goLine:    getEnv("GOLINE"),
	}
	flagSet := flag.NewFlagSet("generate", flag.ContinueOnError)
	flagSet.StringVar(&g.outputFilename, outputFlagFlagName, "template_routes.go", "file name of generated output")
	flagSet.StringVar(&g.templatesVariable, templatesVariable, muxt.DefaultTemplatesVariableName, "templates variable name")
	flagSet.StringVar(&g.routesFunction, routesFunc, muxt.DefaultRoutesFunctionName, "file name of generated output")
	flagSet.StringVar(&g.receiverIdent, receiverStaticType, "", "static receiver type identifier")
	if err := flagSet.Parse(args); err != nil {
		return Generate{}, err
	}
	if g.templatesVariable != "" && !token.IsIdentifier(g.templatesVariable) {
		return Generate{}, fmt.Errorf(templatesVariable + errIdentSuffix)
	}
	if g.routesFunction != "" && !token.IsIdentifier(g.routesFunction) {
		return Generate{}, fmt.Errorf(routesFunc + errIdentSuffix)
	}
	if g.receiverIdent != "" && !token.IsIdentifier(g.receiverIdent) {
		return Generate{}, fmt.Errorf(receiverStaticType + errIdentSuffix)
	}
	return g, nil
}

func generateCommand(args []string, workingDirectory string, getEnv func(string) string, stdout, stderr io.Writer) error {
	g, err := newGenerate(args, getEnv)
	if err != nil {
		return err
	}
	_ = os.Remove(filepath.Join(workingDirectory, g.outputFilename))
	list, err := packages.Load(&packages.Config{
		Mode:  packages.NeedFiles | packages.NeedSyntax | packages.NeedEmbedPatterns | packages.NeedEmbedFiles,
		Dir:   workingDirectory,
		Tests: false,
	}, workingDirectory)
	if err != nil {
		return err
	}
	if g.goPackage != "" {
		i := slices.IndexFunc(list, func(p *packages.Package) bool { return p.ID == g.goPackage })
		if i < 0 {
			return fmt.Errorf("package %s not loaded", g.goPackage)
		}
		g.Package = list[i]
	} else if len(list) > 0 {
		g.Package = list[0]
	}
	ts, err := source.Templates(workingDirectory, g.templatesVariable, g.Package.Fset, g.Package.Syntax, g.Package.EmbedFiles)
	if err != nil {
		return err
	}
	patterns, err := muxt.TemplatePatterns(ts)
	if err != nil {
		return err
	}
	out := log.New(stdout, "", 0)
	s, err := muxt.Generate(patterns, g.goPackage, g.templatesVariable, g.routesFunction, g.receiverIdent, g.Package.Fset, g.Package.Syntax, g.Package.Syntax, out)
	if err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(workingDirectory, g.outputFilename), []byte(CodeGenerationComment+"\n\n"+s), 0o644)
}
