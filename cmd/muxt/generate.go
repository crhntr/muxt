package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"

	"golang.org/x/tools/go/packages"

	"github.com/crhntr/muxt"
)

const (
	CodeGenerationComment = "// Code generated by muxt. DO NOT EDIT."

	outputFlagFlagName    = "output-file"
	templatesVariable     = "templates-variable"
	routesFunc            = "routes-func"
	receiverStaticType    = "receiver-type"
	receiverInterfaceName = "receiver-interface"

	errIdentSuffix = " value must be a well-formed Go identifier"
)

type Generate struct {
	Package *packages.Package
	goFile  string
	goLine  string

	templatesVariable string
	outputFilename    string
	routesFunction    string
	receiverIdent     string

	receiverInterfaceIdent string
}

func newGenerate(args []string, getEnv func(string) string, stderr io.Writer) (Generate, error) {
	g := Generate{
		goFile: getEnv("GOFILE"),
		goLine: getEnv("GOLINE"),
	}
	flagSet := flag.NewFlagSet("generate", flag.ContinueOnError)
	flagSet.SetOutput(stderr)
	flagSet.StringVar(&g.outputFilename, outputFlagFlagName, muxt.DefaultOutputFileName, "file name of generated output")
	flagSet.StringVar(&g.templatesVariable, templatesVariable, muxt.DefaultTemplatesVariableName, "templates variable name")
	flagSet.StringVar(&g.routesFunction, routesFunc, muxt.DefaultRoutesFunctionName, "file name of generated output")
	flagSet.StringVar(&g.receiverIdent, receiverStaticType, "", "static receiver type identifier")
	flagSet.StringVar(&g.receiverInterfaceIdent, receiverInterfaceName, muxt.DefaultReceiverInterfaceName, "generated interface name")
	if err := flagSet.Parse(args); err != nil {
		return Generate{}, err
	}
	if g.templatesVariable != "" && !token.IsIdentifier(g.templatesVariable) {
		return Generate{}, fmt.Errorf(templatesVariable + errIdentSuffix)
	}
	if g.routesFunction != "" && !token.IsIdentifier(g.routesFunction) {
		return Generate{}, fmt.Errorf(routesFunc + errIdentSuffix)
	}
	if g.receiverIdent != "" && !token.IsIdentifier(g.receiverIdent) {
		return Generate{}, fmt.Errorf(receiverStaticType + errIdentSuffix)
	}
	if g.receiverInterfaceIdent != "" && !token.IsIdentifier(g.receiverInterfaceIdent) {
		return Generate{}, fmt.Errorf(receiverInterfaceName + errIdentSuffix)
	}
	if g.outputFilename != "" && filepath.Ext(g.outputFilename) != ".go" {
		return Generate{}, fmt.Errorf("output filename must use .go extension")
	}
	return g, nil
}

func generateCommand(args []string, workingDirectory string, getEnv func(string) string, stdout, stderr io.Writer) error {
	g, err := newGenerate(args, getEnv, stderr)
	if err != nil {
		return err
	}
	s, err := muxt.TemplateRoutesFile(workingDirectory, log.New(stdout, "", 0), muxt.RoutesFileConfiguration{
		Package:           getEnv("GOPACKAGE"),
		TemplatesVar:      g.templatesVariable,
		RoutesFunc:        g.routesFunction,
		ReceiverType:      g.receiverIdent,
		ReceiverInterface: g.receiverInterfaceIdent,
		Output:            g.outputFilename,
	})
	if err != nil {
		return err
	}
	var sb bytes.Buffer
	writeCodeGenerationComment(&sb)
	sb.WriteString(s)
	return os.WriteFile(filepath.Join(workingDirectory, g.outputFilename), sb.Bytes(), 0o644)
}

func writeCodeGenerationComment(w io.StringWriter) {
	_, _ = w.WriteString(CodeGenerationComment)
	if v, ok := cliVersion(); ok {
		_, _ = w.WriteString("\n// muxt version: ")
		_, _ = w.WriteString(v)
		_, _ = w.WriteString("\n\n")
	}
}
